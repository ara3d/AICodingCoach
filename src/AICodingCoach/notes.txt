
Done:
* System now compiles code.
* I get text complete and I get 
* Replaced RoslynPad 
* Interface with AI looks like a chat. 
* Formatted ChatGPT output better
* Made code have a different font
* Add a "copy" button for code. 
* Make the scroll bars visible on the code.
* "return" key in prompt now 
* System prompt is read from a file
* Animation works 
* Fixed a number of threading issues. 
* Added an icon
* Scrolls new messages into view. 
* Added folders for models, services, views, and view-models.
* Fixed more threading issues. 
* Improved prompt. 
* Diagnostics are now above the canvas (as big as required)
* Adding Ara3D utility for synchronizing work. 
* Refactoring the Domo system. 
* Adding settings file 
* Adding application folders data
* Adding a main service  
* Replaced the command class with something from 
* Fixed a problem in reading the prompt file
* No longer using placeholder text in the chat.
* Added a context menu to code editor (cut, copy, paste, undo, redo, explain)
* Added support for detailed and succinct explanations
* Fixed bug with JSON deserialization of readonly properties
* Improved the prompt. 
* Renaming view models and controllers so they make more sense. 
* Setting up initial repositories 

To-do:

Today:
* Allow the saving and loading of workspaces 
* Improve the styling 
* Create a video 
* Create some example 
* Context menu to add, remove, rename, move workspaces
* Allow moving between projects. 

//==


Very High:
* The settings file reading and writing isn't working perfectly yet. 
	* When reading/writing a repository it needs to include the GUIDs.
	* This should be in a test file for Domo. 
	* Outside of the AICodingCoach 

High
* Incorporate repositories and services from Ara3D.Domo
* I want to save code, history, and chat history. 
* I need to have a workspace file 
* button to add a new project
* switching tabs, switches project
* switching projects, switches conversation 
* workflow for accessing and reading from API key 
* workflow for authentication 
* Move to using models and repositories
* Try with Turbo 3.5 - see if I get similar results
* Backup service 
* Timer service
* Event scheduling on main thread
	* Find a cross-platform way to do this: using TaskScheduler? 
	* Need to test within the Domo app. 
* Settings file
	* Is there a settings service
* Command-prompt parser
* Referring to models across repositories.
* Data folder with built-in settings. 
* Define the structure of a workspace. 
* Put the Ara3D code in a nuget. 
* Update prompt so that it is more succinct. 

Medium:
* I am creating a new DLL every time someone writes some code. There must be a better way to do it.
* I should try using "Graphics" instead of Drawing Context 
* Figure out how to make a model's list field behave like an observable collection
* Figure out main menu
* Create commands for main workflow actions. 
	* Maybe all commands are always accessible from any view model 
* Organization of controls into a separate project 
* A special build for release . 
	* If you get the code from Github, it compiles differently.
	* So this implies a production build that is different 
	* A production build uses authentication. 
	* Every other build expects a key in a public space. 
* Put Ara3D code in public nuget 
* Move more utility code to Ara3D.Utils 
* Investigate Fine-tuning of model
* Move to Ara3D event bus, and add capability to use dispatcher for responding to events 
* Improve the cancel capabilities - no exceptions.
* Robust error handling 
* Logging - 
* Use binding more effectively 
* Delete project
* Rename project 
* Clone project 
* Click on error, and it says explain the code. 
* Ability to select code and have it explained
* Put the system prompt in a folder that people can find. 
* Add a post-build step that copies files to where they should go


Low
* Syntax coloring / formatting is not great.
* I can't figure out why certain words (like public) are bolded and others (like class) aren't. 
* This kind of stuff should be editably dynamically. 
* Context menu for editor (cut/copy/paste)
* Personality drop-down 
* Ability to use replacement tags in a prompt {mycode}. 
* A set of tests 
* Log-in splash? 
* Change LLM 
* When something interesting happens, I want to save that work and move to it 
* A console app version
* A debuggable UI version of the app 
* Unload of assemblies (use an AppDomain)
* Editable settings.
* Code insertion 
* Improve the UI of the "copy button"
* Pull-down for predefined prompts 
* Some prompts in the menu. 

Very Low 
* I want run, play, pause, restart, buttons 
* Make the scroll bars visible in the context
* I want the chat to spontaneously say things. 
* Make a UI that looks like a chat. 
* Come up with an icon for the user 
* Command to select and copy entire transcript 
* A "random" prompt. 
* Formatting of code text 
* Improved color scheme
* All styling in a separate project? 
* Improved Chrome 
* Bundle and share the workspace with others (via Github)
* Knowledge base
* Improve the "AssemblyInfo"
* Format inline code bits (suggests that I use RichText or Flow)
* Spontaneous hints 
* Prompt can explain the program 
	* Maybe it is a special "About tab"
* Write a sonnet about how awesome of a programmer I am. 

Probably Not
* Being able to select part of the transcript, across messages. 
* Dark mode theme.
* Github integration on a workspace. 
* Talk to StackOverflow
* Projects have a "color" or "icon"

After
* An article on how I built this. 
* Optimize costs
	* Add some throttling so people don't abuse it.
	* Focus on pre-defined prompts. 
	* Maybe dynamically swap between models. 
	* Minimize the text created. 
* Document the architecture
* Make this easy to compile 

Notes and questions
* How to share a model across repositories 
	* ModelReference<T>? 
	* ModelReferenceCollection<T>?
	* Uses Guids
	* Needs a Guid for the repository I think 
* Do I customize "where" the workspaces are stored? 
	* During development it is defined in one place. 
	* During production it should be stored somewhere else. 
* First step is probably 
	* Define some models. 
* Where do I put the controllers? 
	* View? 
	* ViewModel? 
	* How many are there? 
* Right not I am trying to solve the challenge of adding text. 
	* I am doing it in the view message ... but it is kind of tough. 
	* The whole splitting thing isn't clear. We get some text come in, and then we have to split it 
		... sometimes?
	* This really shouldn't have anything to do with a view model in my opinion. 
	* It is almost a service. Like we are appending some text to the chat. 
	* I think there should be a project service. 
	* Who would own it? I don't think it really matters. There could be multiple ones. 
	* The point of the project service, is to have something that can be used for operating on a project 
		and simplifying the logic. 
	* it seems weird to have the view models creating services? 
	* The thing is that the services should never see the view models, and that is as valid a way to handle 
		it as we can imagine.
	* This is a stateless service. 
	* Which suggests to me that this is simple a bunch of extension methods that operate on projects. 
		
