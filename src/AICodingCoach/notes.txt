
Done:
* System now compiles code.
* I get text complete and I get 
* Replaced RoslynPad 
* Interface with AI looks like a chat. 
* Formatted ChatGPT output better
* Made code have a different font
* Add a "copy" button for code. 
* Make the scroll bars visible on the code.
* "return" key in prompt now 
* System prompt is read from a file
* Animation works 
* Fixed a number of threading issues. 
* Added an icon
* Scrolls new messages into view. 
* Added folders for models, services, views, and view-models.
* Fixed more threading issues. 
* Improved prompt. 
* Diagnostics are now above the canvas (as big as required)
* Adding Ara3D utility for synchronizing work. 
* Refactoring the Domo system. 
* Adding settings file 
* Adding application folders data
* Adding a main service  
* Replaced the command class with something from 
* Fixed a problem in reading the prompt file
* No longer using placeholder text in the chat.
* Added a context menu to code editor (cut, copy, paste, undo, redo, explain)
* Added support for detailed and succinct explanations
* Fixed bug with JSON deserialization of readonly properties
* Improved the prompt. 
* Renaming view models and controllers so they make more sense. 
* Setting up initial repositories 
* Started using view models and services
* Fixed some event-handler leaks in Chat message view models (others still remain). 
* Adding a project service for better handling the message splitting 


To-do:

Today:
* Allow the saving and loading of workspaces 
* Improve the styling 
* Create a video 
* Create some example 
* Context menu to add, remove, rename, move workspaces
* Allow moving between projects. 

//==

Very High:
* The settings file reading and writing isn't working perfectly yet. 
	* When reading/writing a repository it needs to include the GUIDs.
	* This should be in a test file for Domo. 
	* Outside of the AICodingCoach 
* Messages are happening out of order 
* Deleted View models are still getting notifications. 
	* This causes a lot of excess events and resource leaking. 
* Make splitting happen again. 
* Messages should be sorted in the order in which they appear. 
* I want blank messages to exist, acting as dividers.
	* I can delete them later. 
* Load the prompt from a user specified folder. 
* Tell the user when the prompt is not correct 
* Disable to the prompts. 

High
* Incorporate repositories and services from Ara3D.Domo
* I want to save code, history, and chat history. 
* I need to have a workspace file 
* button to add a new project
* switching tabs, switches project
* switching projects, switches conversation 
* workflow for accessing and reading from API key 
* workflow for authentication 
* Move to using models and repositories
* Try with Turbo 3.5 - see if I get similar results
* Backup service 
* Timer service
* Event scheduling on main thread
	* Find a cross-platform way to do this: using TaskScheduler? 
	* Need to test within the Domo app. 
* Settings file
	* Is there a settings service
* Command-prompt parser
* Referring to models across repositories.
* Data folder with built-in settings. 
* Define the structure of a workspace. 
* Put the Ara3D code in a nuget. 
* Update prompt so that it is more succinct. 
* I am going to need to bind the code in the editor to the project model.
	* So that when a project is loaded it shows (e.g., get the initial "// Hello world")
	* So that projects save their data 


Medium:
* I am creating a new DLL every time someone writes some code. There must be a better way to do it.
* I should try using "Graphics" instead of Drawing Context 
* Figure out how to make a model's list field behave like an observable collection
* Figure out main menu
* Create commands for main workflow actions. 
	* Maybe all commands are always accessible from any view model 
* Organization of controls into a separate project 
* A special build for release . 
	* If you get the code from Github, it compiles differently.
	* So this implies a production build that is different 
	* A production build uses authentication. 
	* Every other build expects a key in a public space. 
* Put Ara3D code in public nuget 
* Move more utility code to Ara3D.Utils 
* Investigate Fine-tuning of model
* Move to Ara3D event bus, and add capability to use dispatcher for responding to events 
* Improve the cancel capabilities - no exceptions.
* Robust error handling 
* Logging - 
* Use binding more effectively 
* Delete project
* Rename project 
* Clone project 
* Click on error, and it says explain the code. 
* Ability to select code and have it explained
* Put the system prompt in a folder that people can find. 
* Add a post-build step that copies files to where they should go
* Explain errors 
* Suggest prompts - start with a context menu.
* Put back the menu. 
* Domo has a problem with events. It is easy to create a binding to an event in a view model. 
* Auto-backup service 

Low
* Writes lots of exception handlers 
* Syntax coloring / formatting is not great.
* I can't figure out why certain words (like public) are bolded and others (like class) aren't. 
* This kind of stuff should be editably dynamically. 
* Context menu for editor (cut/copy/paste)
* Personality drop-down 
* Ability to use replacement tags in a prompt {mycode}. 
* A set of tests 
* Log-in splash? 
* Change LLM 
* When something interesting happens, I want to save that work and move to it 
* A console app version
* A debuggable UI version of the app 
* Unload of assemblies (use an AppDomain)
* Editable settings.
* Code insertion 
* Improve the UI of the "copy button"
* Pull-down for predefined prompts 
* Some prompts in the menu. 
* Domo Models need some debugger support, they are hard to read and parse. 

Very Low 
* I want run, play, pause, restart, buttons 
* Make the scroll bars visible in the context
* I want the chat to spontaneously say things. 
* Make a UI that looks like a chat. 
* Come up with an icon for the user 
* Command to select and copy entire transcript 
* A "random" prompt. 
* Formatting of code text 
* Improved color scheme
* All styling in a separate project? 
* Improved Chrome 
* Bundle and share the workspace with others (via Github)
* Knowledge base
* Improve the "AssemblyInfo"
* Format inline code bits (suggests that I use RichText or Flow)
* Spontaneous hints 
* Prompt can explain the program 
	* Maybe it is a special "About tab"
* Write a sonnet about how awesome of a programmer I am. 
* There isn async problem, 
Probably Not
* Being able to select part of the transcript, across messages. 
* Dark mode theme.
* Github integration on a workspace. 
* Talk to StackOverflow
* Projects have a "color" or "icon"

After
* An article on how I built this. 
* Optimize costs
	* Add some throttling so people don't abuse it.
	* Focus on pre-defined prompts. 
	* Maybe dynamically swap between models. 
	* Minimize the text created. 
* Document the architecture
* Make this easy to compile 

Notes and questions
* How to share a model across repositories 
	* ModelReference<T>? 
	* ModelReferenceCollection<T>?
	* Uses Guids
	* Needs a Guid for the repository I think 
* Do I customize "where" the workspaces are stored? 
	* During development it is defined in one place. 
	* During production it should be stored somewhere else. 
* First step is probably 
	* Define some models. 
* Where do I put the controllers? 
	* View? 
	* ViewModel? 
	* How many are there? 
* Right not I am trying to solve the challenge of adding text. 
	* I am doing it in the view message ... but it is kind of tough. 
	* The whole splitting thing isn't clear. We get some text come in, and then we have to split it 
		... sometimes?
	* This really shouldn't have anything to do with a view model in my opinion. 
	* It is almost a service. Like we are appending some text to the chat. 
	* I think there should be a project service. 
	* Who would own it? I don't think it really matters. There could be multiple ones. 
	* The point of the project service, is to have something that can be used for operating on a project 
		and simplifying the logic. 
	* it seems weird to have the view models creating services? 
	* The thing is that the services should never see the view models, and that is as valid a way to handle 
		it as we can imagine.
	* This is a stateless service. 
	* Which suggests to me that this is simple a bunch of extension methods that operate on projects. 
* The repository is out of order. That is fine though.
* Then the problem is that synchronizing view models with models means that perhaps I should use GUIDs. 
* To improver performance, and minimize leakage, I should bind to the model. 
* One solution: 
	* create a ViewModel library for Domo that properly implements IDispose 
		* It could contain some of the useful things like generating view models from models.
		* Perhaps we could also have an IViewModel? 
		* I kind of like this ... 
		* Then what about also having an IView? 
			* Maybe we can have better support for design-time data. 
			* Maybe even theming and other such things. 
			* And type-safe Data contexts? 
	* Another solution is to use EventBus for notifications. 
		* If I go down the route of having an EventBus embedded in Domo
		* It becomes less useful for other contexts. 
		* But it also becomes a more powerful library. 
* How well-known is the leaking event problem? 
* WHat I love about event bus, is that I can diagnose problems in one place. 
* I can also perform optimizations.
* If you subscribe to an event, you probably want to be an IDisposable 
	* So that you can unsubscribe, and not keep them around
* If you publish events, you may also want to implement IDisposable. 
	* So that you can detach all listeners, so that they can be deleted.
* Is there a way to better automate this safe event pattern? 
	* I could write something in a base class, I suppose. 
	* Easier if I have a "IDisposingNotifier". Which gets complicated. 
* Can't two way bind to message data. 