Done:
* System now compiles code.
* I get text complete and I get 
* Replaced RoslynPad 
* Interface with AI looks like a chat. 
* Formatted ChatGPT output better
* Made code have a different font
* Add a "copy" button for code. 
* Make the scroll bars visible on the code.
* "return" key in prompt now 
* System prompt is read from a file
* Animation works 
* Fixed a number of threading issues. 
* Added an icon
* Scrolls new messages into view. 
* Added folders for models, services, views, and view-models.
* Fixed more threading issues. 
* Improved prompt. 
* Diagnostics are now above the canvas (as big as required)
* Adding Ara3D utility for synchronizing work. 
* Refactoring the Domo system. 
* Adding settings file 
* Adding application folders data
* Adding a main service  
* Replaced the command class with something from 
* Fixed a problem in reading the prompt file
* No longer using placeholder text in the chat.
* Added a context menu to code editor (cut, copy, paste, undo, redo, explain)
* Added support for detailed and succinct explanations
* Fixed bug with JSON deserialization of readonly properties
* Improved the prompt. 
* Renaming view models and controllers so they make more sense. 
* Setting up initial repositories 
* Started using view models and services
* Fixed some event-handler leaks in Chat message view models (others still remain). 
* Adding a project service for better handling the message splitting 
* Added some tests
* Significantly improved the splitting algorithm (still some blank messages show)
* Added predefined prompts as context for faster testing and demos. 
* Fixed messages showing up out of order. 
* Fixed binding problem that showed up.
* Auto-saves project data: code, chat-history, and name
* Repaired the Copy button
* Hiding the tabs
* Probably binds to the code in the project model
* Added an idle service.
* Fixed issue with order of messages 
* Disabled animation 

Today:
* Create a video 
* Create some example 

//==

Very High:
* Load the API-key from a user specified folder. 
* Save the project automatically, so I can see what the heck is going on. 
	* Maybe whenever a prompt is submitted? 
	* Or some code is run? 

High
* Improve the styling 
* workflow for accessing and reading from API key 
* workflow for authentication 
* Event scheduling on main thread
	* Find a cross-platform way to do this: using TaskScheduler? 
	* Need to test within the Domo app. 
* Settings file
	* Is there a settings service
* Command-prompt parser
* Referring to models across repositories.
* Data folder with built-in settings. 
* Define the structure of a workspace. 
* Put the Ara3D code in a nuget.
* If we submit twice, it will 

Medium:
* switching tabs, switches project
* switching projects, switches conversation 
* button to add a new project
* Try with Turbo 3.5 - see if I get similar results
* I am creating a new DLL every time someone writes some code. There must be a better way to do it.
* I should try using "Graphics" instead of Drawing Context 
* Figure out how to make a model's list field behave like an observable collection
* Figure out main menu
* Create commands for main workflow actions. 
	* Maybe all commands are always accessible from any view model 
* Organization of controls into a separate project 
* A special build for release . 
	* If you get the code from Github, it compiles differently.
	* So this implies a production build that is different 
	* A production build uses authentication. 
	* Every other build expects a key in a public space. 
* Put Ara3D code in public nuget 
* Move more utility code to Ara3D.Utils 
* Investigate Fine-tuning of model
* Move to Ara3D event bus, and add capability to use dispatcher for responding to events 
* Improve the cancel capabilities - no exceptions.
* Robust error handling 
* Logging - 
* Delete project
* Rename project 
* Clone project 
* Click on error, and it says explain the code. 
* Ability to select code and have it explained
* Put the system prompt in a folder that people can find. 
* Add a post-build step that copies files to where they should go
* Explain errors 
* Put back the menu. 
* Domo has a problem with events. It is easy to create a binding to an event in a view model. 
* When reading/writing a repository it needs to include the GUIDs.

Low
* Writes lots of exception handlers 
* Syntax coloring / formatting is not great.
* I can't figure out why certain words (like public) are bolded and others (like class) aren't. 
* Context menu for editor (cut/copy/paste)
* Personality drop-down 
* Ability to use replacement tags in a prompt {mycode}. 
* A set of tests 
* Log-in splash? 
* Change LLM 
* When something interesting happens, I want to save that work and move to it 
* A console app version
* A debuggable UI version of the app 
* Unload of assemblies (use an AppDomain)
* Editable settings.
* Improve the UI of the "copy button"
* Pull-down for predefined prompts 
* Some prompts in the menu. 
* Domo Models need some debugger support, they are hard to read and parse. 

Very Low 
* I want run, play, pause, restart, buttons 
* Make the scroll bars visible in the context
* I want the chat to spontaneously say things. 
* Make a UI that looks like a chat. 
* Come up with an icon for the user 
* Command to select and copy entire transcript 
* A "random" prompt. 
* Formatting of code text 
* Improved color scheme
* All styling in a separate project? 
* Improved Chrome 
* Bundle and share the workspace with others (via Github)
* Knowledge base
* Improve the "AssemblyInfo"
* Format inline code bits (suggests that I use RichText or Flow)
* Spontaneous hints 
* Prompt can explain the program 
* Maybe it is a special "About tab"
* Write a sonnet about how awesome of a programmer I am. 
* There isn async problem, 
Probably Not
* Being able to select part of the transcript, across messages. 
* Dark mode theme.
* Github integration on a workspace. 
* Talk to StackOverflow
* Projects have a "color" or "icon"


After
* An article on how I built this. 
* Optimize costs
	* Add some throttling so people don't abuse it.
	* Focus on pre-defined prompts. 
	* Maybe dynamically swap between models. 
	* Minimize the text created. 
* Document the architecture
* Make this easy to compile 

Notes and questions
* One solution: 
	* create a ViewModel library for Domo that properly implements IDispose 
		* It could contain some of the useful things like generating view models from models.
		* Perhaps we could also have an IViewModel? 
		* I kind of like this ... 
		* Then what about also having an IView? 
			* Maybe we can have better support for design-time data. 
			* Maybe even theming and other such things. 
			* And type-safe Data contexts? 
	* Another solution is to use EventBus for notifications. 
		* If I go down the route of having an EventBus embedded in Domo
		* It becomes less useful for other contexts. 
		* But it also becomes a more powerful library. 
* How well-known is the leaking event problem? 
* WHat I love about event bus, is that I can diagnose problems in one place. 
* I can also perform optimizations.
* If you subscribe to an event, you probably want to be an IDisposable 
	* So that you can unsubscribe, and not keep them around
* If you publish events, you may also want to implement IDisposable. 
	* So that you can detach all listeners, so that they can be deleted.
* Is there a way to better automate this safe event pattern? 
	* I could write something in a base class, I suppose. 
	* Easier if I have a "IDisposingNotifier". Which gets complicated. 
* Can't two way bind to message data. 

//==

* Explain X, using an example.
	* For loop
	* Pixels
	* Brush
	* Pen
	* Gradient 
	* Function
	* Recursion
	* Random numbers
	* Points 
	* DrawingContext
	* Class
	* Floating point
	* Variables
	* Constants 
	* Expressions 
	* Boolean
	* Logic 
	* If then
	* Sine
	* Cosine
	* Radians
	* RGB Colors
	* Gradients
* Create a shape
	* Star
	* House
	* Face
	* Dog
	* Sierpinski Triangle
	* Mandelbrot Set
	* Spirograph
	* Clock
	* Sine wave
	* 
* Draw an image in the style of:
	* Piet Mondrian
	* Wassily Kandinsky
	* Pablo Picasso
	* Jackson Pollock
	* Vincent Van Gogh
* Modify the previous example
	* To use more functions
	* To make it more interesting
	* To be simpler
	* To have more comments
	* To be shorter 
	* To work better
	* To be more efficient 
	* To eliminate errors 
	* To use fewer constants 
	* To Use implicitly typed variables 
	* To make it more reusable
	* To make it easier to read
	* To make it easier to understandd
	* To make it easier to change
* What 

* Menu
	* File 
		* Open
		* Save
		* Reset
		* Exit
	* View
		* Save Bitmap 
	* Edit 
		* Cut 
		* Copy 
		* Paste
		* Undo
		* Redo
		* Select all
	* Compiler
		* Run code again 
		* Copy errors 
	* Prompts
		* 
	* Help
		* Search the internet 
		* Where to get the source
		* Who wrote this program 
		* How to use the program
		* FAQ
			* What does "Submit" mean
			* What does "No classes." mean
			
